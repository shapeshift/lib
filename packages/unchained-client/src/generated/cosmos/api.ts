/* tslint:disable */
/* eslint-disable */
/**
 * Cosmos Unchained API
 * Provides access to cosmos chain data
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Contains info about account details for an address or xpub
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    pubkey: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    unconfirmedBalance: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    accountNumber: number;
    /**
     * 
     * @type {Array<Value>}
     * @memberof Account
     */
    assets: Array<Value>;
    /**
     * 
     * @type {Array<Delegation>}
     * @memberof Account
     */
    delegations: Array<Delegation>;
    /**
     * 
     * @type {Array<Redelegation>}
     * @memberof Account
     */
    redelegations: Array<Redelegation>;
    /**
     * 
     * @type {Array<Reward>}
     * @memberof Account
     */
    rewards: Array<Reward>;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    sequence: number;
    /**
     * 
     * @type {Array<Unbonding>}
     * @memberof Account
     */
    unbondings: Array<Unbonding>;
}
/**
 * 
 * @export
 * @interface AccountAllOf
 */
export interface AccountAllOf {
    /**
     * 
     * @type {number}
     * @memberof AccountAllOf
     */
    accountNumber: number;
    /**
     * 
     * @type {Array<Value>}
     * @memberof AccountAllOf
     */
    assets: Array<Value>;
    /**
     * 
     * @type {Array<Delegation>}
     * @memberof AccountAllOf
     */
    delegations: Array<Delegation>;
    /**
     * 
     * @type {Array<Redelegation>}
     * @memberof AccountAllOf
     */
    redelegations: Array<Redelegation>;
    /**
     * 
     * @type {Array<Reward>}
     * @memberof AccountAllOf
     */
    rewards: Array<Reward>;
    /**
     * 
     * @type {number}
     * @memberof AccountAllOf
     */
    sequence: number;
    /**
     * 
     * @type {Array<Unbonding>}
     * @memberof AccountAllOf
     */
    unbondings: Array<Unbonding>;
}
/**
 * Generic api error for handling failed requests
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    message: string;
}
/**
 * Contains info about a transaction log event key/val attribute
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    value: string;
}
/**
 * Contains info about a 400 Bad Request response
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    error: string;
}
/**
 * Contains info about required base account details for an address or xpub
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * 
     * @type {string}
     * @memberof BaseAccount
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAccount
     */
    pubkey: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAccount
     */
    unconfirmedBalance: string;
}
/**
 * Contains required base info about the running coinstack
 * @export
 * @interface BaseInfo
 */
export interface BaseInfo {
    /**
     * 
     * @type {string}
     * @memberof BaseInfo
     */
    network: string;
}
/**
 * Contains info about required base transaction details
 * @export
 * @interface BaseTx
 */
export interface BaseTx {
    /**
     * 
     * @type {string}
     * @memberof BaseTx
     */
    blockHash?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseTx
     */
    blockHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseTx
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseTx
     */
    txid: string;
}
/**
 * Contains info about required base transaction history details
 * @export
 * @interface BaseTxHistory
 */
export interface BaseTxHistory {
    /**
     * Base64 encoded string to fetch next page or undefined if no more data avaiable
     * @type {string}
     * @memberof BaseTxHistory
     */
    cursor: string;
    /**
     * 
     * @type {string}
     * @memberof BaseTxHistory
     */
    pubkey: string;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof BaseTxHistory
     */
    txs: Array<Tx>;
}
/**
 * 
 * @export
 * @interface BaseTxHistoryAllOf
 */
export interface BaseTxHistoryAllOf {
    /**
     * 
     * @type {string}
     * @memberof BaseTxHistoryAllOf
     */
    pubkey: string;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof BaseTxHistoryAllOf
     */
    txs: Array<Tx>;
}
/**
 * Contains info about a staking delegation
 * @export
 * @interface Delegation
 */
export interface Delegation {
    /**
     * 
     * @type {Value}
     * @memberof Delegation
     */
    balance: Value;
    /**
     * 
     * @type {string}
     * @memberof Delegation
     */
    shares: string;
    /**
     * 
     * @type {Validator}
     * @memberof Delegation
     */
    validator: Validator;
}
/**
 * Contains info about a transaction log event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof Event
     */
    attributes: Array<Attribute>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    type: string;
}
/**
 * Contains info about the running coinstack
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    annualProvisions: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    apr: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    bondedTokens: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    communityTax: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    totalSupply: string;
}
/**
 * 
 * @export
 * @interface InfoAllOf
 */
export interface InfoAllOf {
    /**
     * 
     * @type {string}
     * @memberof InfoAllOf
     */
    annualProvisions: string;
    /**
     * 
     * @type {string}
     * @memberof InfoAllOf
     */
    apr: string;
    /**
     * 
     * @type {string}
     * @memberof InfoAllOf
     */
    bondedTokens: string;
    /**
     * 
     * @type {string}
     * @memberof InfoAllOf
     */
    communityTax: string;
    /**
     * 
     * @type {string}
     * @memberof InfoAllOf
     */
    totalSupply: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Raw transaction
     * @type {string}
     * @memberof InlineObject
     */
    rawTx: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Raw transaction
     * @type {string}
     * @memberof InlineObject1
     */
    rawTx: string;
}
/**
 * Contains info about a 500 Internal Server Error response
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    message?: string;
}
/**
 * Contains info about a transaction message
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    from?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    origin?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    to?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    type: string;
    /**
     * 
     * @type {Value}
     * @memberof Message
     */
    value?: Value;
}
/**
 * Contains info about pagination metadata
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Base64 encoded string to fetch next page or undefined if no more data avaiable
     * @type {string}
     * @memberof Pagination
     */
    cursor: string;
}
/**
 * Contains info about a staking redelegation
 * @export
 * @interface Redelegation
 */
export interface Redelegation {
    /**
     * 
     * @type {Validator}
     * @memberof Redelegation
     */
    destinationValidator: Validator;
    /**
     * 
     * @type {Array<RedelegationEntry>}
     * @memberof Redelegation
     */
    entries: Array<RedelegationEntry>;
    /**
     * 
     * @type {Validator}
     * @memberof Redelegation
     */
    sourceValidator: Validator;
}
/**
 * Contains info about a redelegation action
 * @export
 * @interface RedelegationEntry
 */
export interface RedelegationEntry {
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    balance: string;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    completionTime: string;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    shares: string;
}
/**
 * Contains info about a validator reward
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {Array<Value>}
     * @memberof Reward
     */
    rewards: Array<Value>;
    /**
     * 
     * @type {Validator}
     * @memberof Reward
     */
    validator: Validator;
}
/**
 * Contains info about a transaction
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    blockHash?: string;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    blockHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    txid: string;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    confirmations: number;
    /**
     * Contains info about tx events keyed by message index
     * @type {{ [key: string]: Array<Event>; }}
     * @memberof Tx
     */
    events: { [key: string]: Array<Event>; };
    /**
     * 
     * @type {Value}
     * @memberof Tx
     */
    fee: Value;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    gasUsed: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    gasWanted: string;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    index: number;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    memo?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Tx
     */
    messages: Array<Message>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    value: string;
}
/**
 * 
 * @export
 * @interface TxAllOf
 */
export interface TxAllOf {
    /**
     * 
     * @type {number}
     * @memberof TxAllOf
     */
    confirmations: number;
    /**
     * Contains info about tx events keyed by message index
     * @type {{ [key: string]: Array<Event>; }}
     * @memberof TxAllOf
     */
    events: { [key: string]: Array<Event>; };
    /**
     * 
     * @type {Value}
     * @memberof TxAllOf
     */
    fee: Value;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    gasUsed: string;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    gasWanted: string;
    /**
     * 
     * @type {number}
     * @memberof TxAllOf
     */
    index: number;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    memo?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof TxAllOf
     */
    messages: Array<Message>;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    value: string;
}
/**
 * Contains info about transaction history for an address or xpub
 * @export
 * @interface TxHistory
 */
export interface TxHistory {
    /**
     * Base64 encoded string to fetch next page or undefined if no more data avaiable
     * @type {string}
     * @memberof TxHistory
     */
    cursor: string;
    /**
     * 
     * @type {string}
     * @memberof TxHistory
     */
    pubkey: string;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxHistory
     */
    txs: Array<Tx>;
}
/**
 * 
 * @export
 * @interface TxHistoryAllOf
 */
export interface TxHistoryAllOf {
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxHistoryAllOf
     */
    txs: Array<Tx>;
}
/**
 * Contains info about a staking unbonding
 * @export
 * @interface Unbonding
 */
export interface Unbonding {
    /**
     * 
     * @type {Array<UnbondingEntry>}
     * @memberof Unbonding
     */
    entries: Array<UnbondingEntry>;
    /**
     * 
     * @type {Validator}
     * @memberof Unbonding
     */
    validator: Validator;
}
/**
 * Contains info about an unbonding action
 * @export
 * @interface UnbondingEntry
 */
export interface UnbondingEntry {
    /**
     * 
     * @type {Value}
     * @memberof UnbondingEntry
     */
    balance: Value;
    /**
     * 
     * @type {string}
     * @memberof UnbondingEntry
     */
    completionTime: string;
}
/**
 * Contains info about a 422 Validation Error response
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ValidationError
     */
    details: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    message: string;
}
/**
 * Contains info about a validator
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    apr: string;
    /**
     * 
     * @type {ValidatorCommission}
     * @memberof Validator
     */
    commission: ValidatorCommission;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof Validator
     */
    jailed: boolean;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    moniker: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    shares: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    tokens: string;
    /**
     * 
     * @type {ValidatorUnbonding}
     * @memberof Validator
     */
    unbonding: ValidatorUnbonding;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    website: string;
}
/**
 * Contains info about validator commission settings
 * @export
 * @interface ValidatorCommission
 */
export interface ValidatorCommission {
    /**
     * 
     * @type {string}
     * @memberof ValidatorCommission
     */
    maxChangeRate: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorCommission
     */
    maxRate: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorCommission
     */
    rate: string;
}
/**
 * Contains info about validator unbonding settings
 * @export
 * @interface ValidatorUnbonding
 */
export interface ValidatorUnbonding {
    /**
     * 
     * @type {number}
     * @memberof ValidatorUnbonding
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUnbonding
     */
    timestamp: number;
}
/**
 * Contains a list of validators
 * @export
 * @interface Validators
 */
export interface Validators {
    /**
     * 
     * @type {Array<Validator>}
     * @memberof Validators
     */
    validators: Array<Validator>;
}
/**
 * Contains info about an asset value
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    denom: string;
}

/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the estimated gas cost for a transaction
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas: async (body?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/gas/estimate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account details.
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (pubkey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('getAccount', 'pubkey', pubkey)
            const localVarPath = `/api/v1/account/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about the running coinstack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get paginated transaction history.
         * @param {string} pubkey Account address or xpub
         * @param {string} [cursor] Pagination cursor from previous response or empty string for first page fetch
         * @param {number} [pageSize] Page size (default 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHistory: async (pubkey: string, cursor?: string, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('getTxHistory', 'pubkey', pubkey)
            const localVarPath = `/api/v1/account/{pubkey}/txs`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific validator
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (pubkey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('getValidator', 'pubkey', pubkey)
            const localVarPath = `/api/v1/validators/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of current validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends raw transaction to be broadcast to the node.
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTx: async (body?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the estimated gas cost for a transaction
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateGas(body?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateGas(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get account details.
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(pubkey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about the running coinstack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get paginated transaction history.
         * @param {string} pubkey Account address or xpub
         * @param {string} [cursor] Pagination cursor from previous response or empty string for first page fetch
         * @param {number} [pageSize] Page size (default 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxHistory(pubkey: string, cursor?: string, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxHistory(pubkey, cursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific validator
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(pubkey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of current validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validators>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sends raw transaction to be broadcast to the node.
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTx(body?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * Get the estimated gas cost for a transaction
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas(body?: InlineObject, options?: any): AxiosPromise<string> {
            return localVarFp.estimateGas(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account details.
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(pubkey: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about the running coinstack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get paginated transaction history.
         * @param {string} pubkey Account address or xpub
         * @param {string} [cursor] Pagination cursor from previous response or empty string for first page fetch
         * @param {number} [pageSize] Page size (default 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHistory(pubkey: string, cursor?: string, pageSize?: number, options?: any): AxiosPromise<TxHistory> {
            return localVarFp.getTxHistory(pubkey, cursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific validator
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(pubkey: string, options?: any): AxiosPromise<Validator> {
            return localVarFp.getValidator(pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of current validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options?: any): AxiosPromise<Validators> {
            return localVarFp.getValidators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends raw transaction to be broadcast to the node.
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTx(body?: InlineObject1, options?: any): AxiosPromise<string> {
            return localVarFp.sendTx(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for estimateGas operation in V1Api.
 * @export
 * @interface V1ApiEstimateGasRequest
 */
export interface V1ApiEstimateGasRequest {
    /**
     * 
     * @type {InlineObject}
     * @memberof V1ApiEstimateGas
     */
    readonly body?: InlineObject
}

/**
 * Request parameters for getAccount operation in V1Api.
 * @export
 * @interface V1ApiGetAccountRequest
 */
export interface V1ApiGetAccountRequest {
    /**
     * Account address or xpub
     * @type {string}
     * @memberof V1ApiGetAccount
     */
    readonly pubkey: string
}

/**
 * Request parameters for getTxHistory operation in V1Api.
 * @export
 * @interface V1ApiGetTxHistoryRequest
 */
export interface V1ApiGetTxHistoryRequest {
    /**
     * Account address or xpub
     * @type {string}
     * @memberof V1ApiGetTxHistory
     */
    readonly pubkey: string

    /**
     * Pagination cursor from previous response or empty string for first page fetch
     * @type {string}
     * @memberof V1ApiGetTxHistory
     */
    readonly cursor?: string

    /**
     * Page size (default 10)
     * @type {number}
     * @memberof V1ApiGetTxHistory
     */
    readonly pageSize?: number
}

/**
 * Request parameters for getValidator operation in V1Api.
 * @export
 * @interface V1ApiGetValidatorRequest
 */
export interface V1ApiGetValidatorRequest {
    /**
     * Account address or xpub
     * @type {string}
     * @memberof V1ApiGetValidator
     */
    readonly pubkey: string
}

/**
 * Request parameters for sendTx operation in V1Api.
 * @export
 * @interface V1ApiSendTxRequest
 */
export interface V1ApiSendTxRequest {
    /**
     * 
     * @type {InlineObject1}
     * @memberof V1ApiSendTx
     */
    readonly body?: InlineObject1
}

/**
 * V1Api - object-oriented interface
 * @export
 * @class V1Api
 * @extends {BaseAPI}
 */
export class V1Api extends BaseAPI {
    /**
     * Get the estimated gas cost for a transaction
     * @param {V1ApiEstimateGasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public estimateGas(requestParameters: V1ApiEstimateGasRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).estimateGas(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account details.
     * @param {V1ApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getAccount(requestParameters: V1ApiGetAccountRequest, options?: any) {
        return V1ApiFp(this.configuration).getAccount(requestParameters.pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about the running coinstack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getInfo(options?: any) {
        return V1ApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get paginated transaction history.
     * @param {V1ApiGetTxHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getTxHistory(requestParameters: V1ApiGetTxHistoryRequest, options?: any) {
        return V1ApiFp(this.configuration).getTxHistory(requestParameters.pubkey, requestParameters.cursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific validator
     * @param {V1ApiGetValidatorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getValidator(requestParameters: V1ApiGetValidatorRequest, options?: any) {
        return V1ApiFp(this.configuration).getValidator(requestParameters.pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of current validators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getValidators(options?: any) {
        return V1ApiFp(this.configuration).getValidators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends raw transaction to be broadcast to the node.
     * @param {V1ApiSendTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public sendTx(requestParameters: V1ApiSendTxRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).sendTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebsocketApi - axios parameter creator
 * @export
 */
export const WebsocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Subscribe to pending and confirmed transactions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocket: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsocketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Subscribe to pending and confirmed transactions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocket(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocket(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsocketApiFp(configuration)
    return {
        /**
         * 
         * @summary Subscribe to pending and confirmed transactions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocket(options?: any): AxiosPromise<void> {
            return localVarFp.websocket(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * 
     * @summary Subscribe to pending and confirmed transactions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocket(options?: any) {
        return WebsocketApiFp(this.configuration).websocket(options).then((request) => request(this.axios, this.basePath));
    }
}


