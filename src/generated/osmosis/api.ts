/* tslint:disable */
/* eslint-disable */
/**
 * Osmosis Unchained API
 * Provides access to osmosis chain data
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Contains info about account details for an address or xpub
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'balance': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'pubkey': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'unconfirmedBalance': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'accountNumber': number;
    /**
     * 
     * @type {Array<Value>}
     * @memberof Account
     */
    'assets': Array<Value>;
    /**
     * 
     * @type {Array<Delegation>}
     * @memberof Account
     */
    'delegations': Array<Delegation>;
    /**
     * 
     * @type {Array<Redelegation>}
     * @memberof Account
     */
    'redelegations': Array<Redelegation>;
    /**
     * 
     * @type {Array<Reward>}
     * @memberof Account
     */
    'rewards': Array<Reward>;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'sequence': number;
    /**
     * 
     * @type {Array<Unbonding>}
     * @memberof Account
     */
    'unbondings': Array<Unbonding>;
}
/**
 * 
 * @export
 * @interface AccountAllOf
 */
export interface AccountAllOf {
    /**
     * 
     * @type {number}
     * @memberof AccountAllOf
     */
    'accountNumber': number;
    /**
     * 
     * @type {Array<Value>}
     * @memberof AccountAllOf
     */
    'assets': Array<Value>;
    /**
     * 
     * @type {Array<Delegation>}
     * @memberof AccountAllOf
     */
    'delegations': Array<Delegation>;
    /**
     * 
     * @type {Array<Redelegation>}
     * @memberof AccountAllOf
     */
    'redelegations': Array<Redelegation>;
    /**
     * 
     * @type {Array<Reward>}
     * @memberof AccountAllOf
     */
    'rewards': Array<Reward>;
    /**
     * 
     * @type {number}
     * @memberof AccountAllOf
     */
    'sequence': number;
    /**
     * 
     * @type {Array<Unbonding>}
     * @memberof AccountAllOf
     */
    'unbondings': Array<Unbonding>;
}
/**
 * Generic api error for handling failed requests
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
}
/**
 * Contains info about a transaction log event key/val attribute
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    'value': string;
}
/**
 * Contains info about a 400 Bad Request response
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    'error': string;
}
/**
 * Contains info about required base account details for an address or xpub
 * @export
 * @interface BaseAccount
 */
export interface BaseAccount {
    /**
     * 
     * @type {string}
     * @memberof BaseAccount
     */
    'balance': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAccount
     */
    'pubkey': string;
    /**
     * 
     * @type {string}
     * @memberof BaseAccount
     */
    'unconfirmedBalance': string;
}
/**
 * Contains required base info about the running coinstack
 * @export
 * @interface BaseInfo
 */
export interface BaseInfo {
    /**
     * 
     * @type {string}
     * @memberof BaseInfo
     */
    'network': string;
}
/**
 * Contains info about required base transaction details
 * @export
 * @interface BaseTx
 */
export interface BaseTx {
    /**
     * 
     * @type {string}
     * @memberof BaseTx
     */
    'blockHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseTx
     */
    'blockHeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseTx
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseTx
     */
    'txid': string;
}
/**
 * Contains info about required base transaction history details
 * @export
 * @interface BaseTxHistory
 */
export interface BaseTxHistory {
    /**
     * Base64 encoded string to fetch next page or undefined if no more data avaiable
     * @type {string}
     * @memberof BaseTxHistory
     */
    'cursor': string;
    /**
     * 
     * @type {string}
     * @memberof BaseTxHistory
     */
    'pubkey': string;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof BaseTxHistory
     */
    'txs': Array<Tx>;
}
/**
 * 
 * @export
 * @interface BaseTxHistoryAllOf
 */
export interface BaseTxHistoryAllOf {
    /**
     * 
     * @type {string}
     * @memberof BaseTxHistoryAllOf
     */
    'pubkey': string;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof BaseTxHistoryAllOf
     */
    'txs': Array<Tx>;
}
/**
 * Contains info about a staking delegation
 * @export
 * @interface Delegation
 */
export interface Delegation {
    /**
     * 
     * @type {Value}
     * @memberof Delegation
     */
    'balance': Value;
    /**
     * 
     * @type {string}
     * @memberof Delegation
     */
    'shares': string;
    /**
     * 
     * @type {Validator}
     * @memberof Delegation
     */
    'validator': Validator;
}
/**
 * Contains info about a transaction log event
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof Event
     */
    'attributes': Array<Attribute>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'type': string;
}
/**
 * Contains info about the running coinstack
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'network': string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'apr': string;
}
/**
 * 
 * @export
 * @interface InfoAllOf
 */
export interface InfoAllOf {
    /**
     * 
     * @type {string}
     * @memberof InfoAllOf
     */
    'apr': string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Raw transaction
     * @type {string}
     * @memberof InlineObject
     */
    'rawTx': string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Raw transaction
     * @type {string}
     * @memberof InlineObject1
     */
    'rawTx': string;
}
/**
 * Contains info about a 500 Internal Server Error response
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'message'?: string;
}
/**
 * Contains info about a transaction message
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'to'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'type': string;
    /**
     * 
     * @type {Value}
     * @memberof Message
     */
    'value'?: Value;
}
/**
 * Contains info about pagination metadata
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Base64 encoded string to fetch next page or undefined if no more data avaiable
     * @type {string}
     * @memberof Pagination
     */
    'cursor': string;
}
/**
 * Contains info about a staking redelegation
 * @export
 * @interface Redelegation
 */
export interface Redelegation {
    /**
     * 
     * @type {Validator}
     * @memberof Redelegation
     */
    'destinationValidator': Validator;
    /**
     * 
     * @type {Array<RedelegationEntry>}
     * @memberof Redelegation
     */
    'entries': Array<RedelegationEntry>;
    /**
     * 
     * @type {Validator}
     * @memberof Redelegation
     */
    'sourceValidator': Validator;
}
/**
 * Contains info about a redelegation action
 * @export
 * @interface RedelegationEntry
 */
export interface RedelegationEntry {
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    'balance': string;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    'completionTime': string;
    /**
     * 
     * @type {string}
     * @memberof RedelegationEntry
     */
    'shares': string;
}
/**
 * Contains info about a validator reward
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {Array<Value>}
     * @memberof Reward
     */
    'rewards': Array<Value>;
    /**
     * 
     * @type {Validator}
     * @memberof Reward
     */
    'validator': Validator;
}
/**
 * Contains info about a transaction
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'blockHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    'blockHeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'txid': string;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    'confirmations': number;
    /**
     * Contains info about tx events keyed by message index
     * @type {{ [key: string]: Array<Event>; }}
     * @memberof Tx
     */
    'events': { [key: string]: Array<Event>; };
    /**
     * 
     * @type {Value}
     * @memberof Tx
     */
    'fee': Value;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'gasUsed': string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'gasWanted': string;
    /**
     * 
     * @type {number}
     * @memberof Tx
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'memo'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Tx
     */
    'messages': Array<Message>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TxAllOf
 */
export interface TxAllOf {
    /**
     * 
     * @type {number}
     * @memberof TxAllOf
     */
    'confirmations': number;
    /**
     * Contains info about tx events keyed by message index
     * @type {{ [key: string]: Array<Event>; }}
     * @memberof TxAllOf
     */
    'events': { [key: string]: Array<Event>; };
    /**
     * 
     * @type {Value}
     * @memberof TxAllOf
     */
    'fee': Value;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    'gasUsed': string;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    'gasWanted': string;
    /**
     * 
     * @type {number}
     * @memberof TxAllOf
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    'memo'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof TxAllOf
     */
    'messages': Array<Message>;
    /**
     * 
     * @type {string}
     * @memberof TxAllOf
     */
    'value': string;
}
/**
 * Contains info about transaction history for an address or xpub
 * @export
 * @interface TxHistory
 */
export interface TxHistory {
    /**
     * Base64 encoded string to fetch next page or undefined if no more data avaiable
     * @type {string}
     * @memberof TxHistory
     */
    'cursor': string;
    /**
     * 
     * @type {string}
     * @memberof TxHistory
     */
    'pubkey': string;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxHistory
     */
    'txs': Array<Tx>;
}
/**
 * 
 * @export
 * @interface TxHistoryAllOf
 */
export interface TxHistoryAllOf {
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxHistoryAllOf
     */
    'txs': Array<Tx>;
}
/**
 * Contains info about a staking unbonding
 * @export
 * @interface Unbonding
 */
export interface Unbonding {
    /**
     * 
     * @type {Array<UnbondingEntry>}
     * @memberof Unbonding
     */
    'entries': Array<UnbondingEntry>;
    /**
     * 
     * @type {Validator}
     * @memberof Unbonding
     */
    'validator': Validator;
}
/**
 * Contains info about an unbonding action
 * @export
 * @interface UnbondingEntry
 */
export interface UnbondingEntry {
    /**
     * 
     * @type {Value}
     * @memberof UnbondingEntry
     */
    'balance': Value;
    /**
     * 
     * @type {string}
     * @memberof UnbondingEntry
     */
    'completionTime': string;
}
/**
 * Contains info about a 422 Validation Error response
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ValidationError
     */
    'details': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'message': string;
}
/**
 * Contains info about a validator
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'apr': string;
    /**
     * 
     * @type {ValidatorCommission}
     * @memberof Validator
     */
    'commission': ValidatorCommission;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Validator
     */
    'jailed': boolean;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'moniker': string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'shares': string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'tokens': string;
    /**
     * 
     * @type {ValidatorUnbonding}
     * @memberof Validator
     */
    'unbonding': ValidatorUnbonding;
    /**
     * 
     * @type {string}
     * @memberof Validator
     */
    'website': string;
}
/**
 * Contains info about validator commission settings
 * @export
 * @interface ValidatorCommission
 */
export interface ValidatorCommission {
    /**
     * 
     * @type {string}
     * @memberof ValidatorCommission
     */
    'maxChangeRate': string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorCommission
     */
    'maxRate': string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorCommission
     */
    'rate': string;
}
/**
 * Contains info about validator unbonding settings
 * @export
 * @interface ValidatorUnbonding
 */
export interface ValidatorUnbonding {
    /**
     * 
     * @type {number}
     * @memberof ValidatorUnbonding
     */
    'height': number;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUnbonding
     */
    'timestamp': number;
}
/**
 * Contains a list of validators
 * @export
 * @interface Validators
 */
export interface Validators {
    /**
     * 
     * @type {Array<Validator>}
     * @memberof Validators
     */
    'validators': Array<Validator>;
}
/**
 * Contains info about an asset value
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    'denom': string;
}

/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the estimated gas cost for a transaction
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas: async (body?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/gas/estimate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account details.
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (pubkey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('getAccount', 'pubkey', pubkey)
            const localVarPath = `/api/v1/account/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about the running coinstack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get paginated transaction history.
         * @param {string} pubkey Account address or xpub
         * @param {string} [cursor] Pagination cursor from previous response or empty string for first page fetch
         * @param {number} [pageSize] Page size (default 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHistory: async (pubkey: string, cursor?: string, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('getTxHistory', 'pubkey', pubkey)
            const localVarPath = `/api/v1/account/{pubkey}/txs`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific validator
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (pubkey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pubkey' is not null or undefined
            assertParamExists('getValidator', 'pubkey', pubkey)
            const localVarPath = `/api/v1/validators/{pubkey}`
                .replace(`{${"pubkey"}}`, encodeURIComponent(String(pubkey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of current validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends raw transaction to be broadcast to the node.
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTx: async (body?: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the estimated gas cost for a transaction
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estimateGas(body?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.estimateGas(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get account details.
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(pubkey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about the running coinstack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Info>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get paginated transaction history.
         * @param {string} pubkey Account address or xpub
         * @param {string} [cursor] Pagination cursor from previous response or empty string for first page fetch
         * @param {number} [pageSize] Page size (default 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxHistory(pubkey: string, cursor?: string, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TxHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxHistory(pubkey, cursor, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific validator
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(pubkey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(pubkey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of current validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidators(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validators>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sends raw transaction to be broadcast to the node.
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTx(body?: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * Get the estimated gas cost for a transaction
         * @param {InlineObject} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estimateGas(body?: InlineObject, options?: any): AxiosPromise<string> {
            return localVarFp.estimateGas(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get account details.
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(pubkey: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about the running coinstack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<Info> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get paginated transaction history.
         * @param {string} pubkey Account address or xpub
         * @param {string} [cursor] Pagination cursor from previous response or empty string for first page fetch
         * @param {number} [pageSize] Page size (default 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxHistory(pubkey: string, cursor?: string, pageSize?: number, options?: any): AxiosPromise<TxHistory> {
            return localVarFp.getTxHistory(pubkey, cursor, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific validator
         * @param {string} pubkey Account address or xpub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(pubkey: string, options?: any): AxiosPromise<Validator> {
            return localVarFp.getValidator(pubkey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of current validators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options?: any): AxiosPromise<Validators> {
            return localVarFp.getValidators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends raw transaction to be broadcast to the node.
         * @param {InlineObject1} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTx(body?: InlineObject1, options?: any): AxiosPromise<string> {
            return localVarFp.sendTx(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for estimateGas operation in V1Api.
 * @export
 * @interface V1ApiEstimateGasRequest
 */
export interface V1ApiEstimateGasRequest {
    /**
     * 
     * @type {InlineObject}
     * @memberof V1ApiEstimateGas
     */
    readonly body?: InlineObject
}

/**
 * Request parameters for getAccount operation in V1Api.
 * @export
 * @interface V1ApiGetAccountRequest
 */
export interface V1ApiGetAccountRequest {
    /**
     * Account address or xpub
     * @type {string}
     * @memberof V1ApiGetAccount
     */
    readonly pubkey: string
}

/**
 * Request parameters for getTxHistory operation in V1Api.
 * @export
 * @interface V1ApiGetTxHistoryRequest
 */
export interface V1ApiGetTxHistoryRequest {
    /**
     * Account address or xpub
     * @type {string}
     * @memberof V1ApiGetTxHistory
     */
    readonly pubkey: string

    /**
     * Pagination cursor from previous response or empty string for first page fetch
     * @type {string}
     * @memberof V1ApiGetTxHistory
     */
    readonly cursor?: string

    /**
     * Page size (default 10)
     * @type {number}
     * @memberof V1ApiGetTxHistory
     */
    readonly pageSize?: number
}

/**
 * Request parameters for getValidator operation in V1Api.
 * @export
 * @interface V1ApiGetValidatorRequest
 */
export interface V1ApiGetValidatorRequest {
    /**
     * Account address or xpub
     * @type {string}
     * @memberof V1ApiGetValidator
     */
    readonly pubkey: string
}

/**
 * Request parameters for sendTx operation in V1Api.
 * @export
 * @interface V1ApiSendTxRequest
 */
export interface V1ApiSendTxRequest {
    /**
     * 
     * @type {InlineObject1}
     * @memberof V1ApiSendTx
     */
    readonly body?: InlineObject1
}

/**
 * V1Api - object-oriented interface
 * @export
 * @class V1Api
 * @extends {BaseAPI}
 */
export class V1Api extends BaseAPI {
    /**
     * Get the estimated gas cost for a transaction
     * @param {V1ApiEstimateGasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public estimateGas(requestParameters: V1ApiEstimateGasRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).estimateGas(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get account details.
     * @param {V1ApiGetAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getAccount(requestParameters: V1ApiGetAccountRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getAccount(requestParameters.pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about the running coinstack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getInfo(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get paginated transaction history.
     * @param {V1ApiGetTxHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getTxHistory(requestParameters: V1ApiGetTxHistoryRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getTxHistory(requestParameters.pubkey, requestParameters.cursor, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific validator
     * @param {V1ApiGetValidatorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getValidator(requestParameters: V1ApiGetValidatorRequest, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getValidator(requestParameters.pubkey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of current validators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public getValidators(options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).getValidators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends raw transaction to be broadcast to the node.
     * @param {V1ApiSendTxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public sendTx(requestParameters: V1ApiSendTxRequest = {}, options?: AxiosRequestConfig) {
        return V1ApiFp(this.configuration).sendTx(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebsocketApi - axios parameter creator
 * @export
 */
export const WebsocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Subscribe to pending and confirmed transactions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocket: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsocketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Subscribe to pending and confirmed transactions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocket(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocket(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsocketApiFp(configuration)
    return {
        /**
         * 
         * @summary Subscribe to pending and confirmed transactions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocket(options?: any): AxiosPromise<void> {
            return localVarFp.websocket(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * 
     * @summary Subscribe to pending and confirmed transactions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocket(options?: AxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocket(options).then((request) => request(this.axios, this.basePath));
    }
}


